{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { crop, flip, resize, rotate } from \"./actions/index.web\";\nimport { getContext } from \"./utils/getContext.web\";\n\nfunction getResults(canvas, options) {\n  var uri;\n\n  if (options) {\n    var _options$compress;\n\n    var _options$format = options.format,\n        format = _options$format === void 0 ? 'png' : _options$format;\n\n    if (options.format === 'png' && options.compress !== undefined) {\n      console.warn('compress is not supported with png format.');\n    }\n\n    var quality = Math.min(1, Math.max(0, (_options$compress = options.compress) != null ? _options$compress : 1));\n    uri = canvas.toDataURL('image/' + format, quality);\n  } else {\n    uri = canvas.toDataURL();\n  }\n\n  return {\n    uri: uri,\n    width: canvas.width,\n    height: canvas.height,\n    base64: uri.replace(/^data:image\\/\\w+;base64,/, '')\n  };\n}\n\nfunction loadImageAsync(uri) {\n  return new Promise(function (resolve, reject) {\n    var imageSource = new Image();\n    imageSource.crossOrigin = 'anonymous';\n    var canvas = document.createElement('canvas');\n\n    imageSource.onload = function () {\n      canvas.width = imageSource.naturalWidth;\n      canvas.height = imageSource.naturalHeight;\n      var context = getContext(canvas);\n      context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n      resolve(canvas);\n    };\n\n    imageSource.onerror = function () {\n      return reject(canvas);\n    };\n\n    imageSource.src = uri;\n  });\n}\n\nexport default {\n  get name() {\n    return 'ExpoImageManipulator';\n  },\n\n  manipulateAsync: function () {\n    var _manipulateAsync = _asyncToGenerator(function* (uri) {\n      var actions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var options = arguments.length > 2 ? arguments[2] : undefined;\n      var originalCanvas = yield loadImageAsync(uri);\n      var resultCanvas = actions.reduce(function (canvas, action) {\n        if ('crop' in action) {\n          return crop(canvas, action.crop);\n        } else if ('resize' in action) {\n          return resize(canvas, action.resize);\n        } else if ('flip' in action) {\n          return flip(canvas, action.flip);\n        } else if ('rotate' in action) {\n          return rotate(canvas, action.rotate);\n        } else {\n          return canvas;\n        }\n      }, originalCanvas);\n      return getResults(resultCanvas, options);\n    });\n\n    function manipulateAsync(_x) {\n      return _manipulateAsync.apply(this, arguments);\n    }\n\n    return manipulateAsync;\n  }()\n};","map":{"version":3,"mappings":"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","names":["crop","flip","resize","rotate","getContext","getResults","canvas","options","uri","format","compress","undefined","console","warn","quality","Math","min","max","toDataURL","width","height","base64","replace","loadImageAsync","Promise","resolve","reject","imageSource","Image","crossOrigin","document","createElement","onload","naturalWidth","naturalHeight","context","drawImage","onerror","src","name","manipulateAsync","actions","originalCanvas","resultCanvas","reduce","action"],"sourceRoot":"","sources":["../src/ExpoImageManipulator.web.ts"],"sourcesContent":["import { ImageResult, SaveOptions, Action } from './ImageManipulator.types';\nimport { crop, flip, resize, rotate } from './actions/index.web';\nimport { getContext } from './utils/getContext.web';\n\nfunction getResults(canvas: HTMLCanvasElement, options?: SaveOptions): ImageResult {\n  let uri: string;\n  if (options) {\n    const { format = 'png' } = options;\n    if (options.format === 'png' && options.compress !== undefined) {\n      console.warn('compress is not supported with png format.');\n    }\n    const quality = Math.min(1, Math.max(0, options.compress ?? 1));\n    uri = canvas.toDataURL('image/' + format, quality);\n  } else {\n    // defaults to PNG with no loss\n    uri = canvas.toDataURL();\n  }\n  return {\n    uri,\n    width: canvas.width,\n    height: canvas.height,\n    base64: uri.replace(/^data:image\\/\\w+;base64,/, ''),\n  };\n}\n\nfunction loadImageAsync(uri: string): Promise<HTMLCanvasElement> {\n  return new Promise((resolve, reject) => {\n    const imageSource = new Image();\n    imageSource.crossOrigin = 'anonymous';\n    const canvas = document.createElement('canvas');\n    imageSource.onload = () => {\n      canvas.width = imageSource.naturalWidth;\n      canvas.height = imageSource.naturalHeight;\n\n      const context = getContext(canvas);\n      context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n\n      resolve(canvas);\n    };\n    imageSource.onerror = () => reject(canvas);\n    imageSource.src = uri;\n  });\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoImageManipulator';\n  },\n  async manipulateAsync(\n    uri: string,\n    actions: Action[] = [],\n    options: SaveOptions\n  ): Promise<ImageResult> {\n    const originalCanvas = await loadImageAsync(uri);\n\n    const resultCanvas = actions.reduce((canvas, action) => {\n      if ('crop' in action) {\n        return crop(canvas, action.crop);\n      } else if ('resize' in action) {\n        return resize(canvas, action.resize);\n      } else if ('flip' in action) {\n        return flip(canvas, action.flip);\n      } else if ('rotate' in action) {\n        return rotate(canvas, action.rotate);\n      } else {\n        return canvas;\n      }\n    }, originalCanvas);\n\n    return getResults(resultCanvas, options);\n  },\n};\n"]},"metadata":{},"sourceType":"module"}