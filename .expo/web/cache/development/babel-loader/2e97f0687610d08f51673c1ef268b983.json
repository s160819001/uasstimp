{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs = Math.abs;\nvar now = Date.now;\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n\nvar win;\n\nif (typeof window === \"undefined\") {\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation';\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = ('ontouchstart' in win);\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\nfunction cleanTouchActions(actions) {\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n\nvar TouchAction = function () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection;\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length;\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\nfunction simpleCloneInputData(input) {\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center;\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length;\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input);\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n\n  input.target = target;\n}\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  input.eventType = eventType;\n  computeInputData(manager, input);\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\nvar Input = function () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n};\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\nvar PointerEventInput = function (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH;\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    }\n\n    if (storeIndex < 0) {\n      return;\n    }\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\nvar TouchInput = function (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {};\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds;\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target;\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  });\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\nvar MouseInput = function (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false;\n    return _this;\n  }\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type];\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    }\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput = function () {\n  var TouchMouseInput = function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        }\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n\n    var _proto = TouchMouseInput.prototype;\n\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n\nfunction createInputInstance(manager) {\n  var Type;\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\nvar _uniqueId = 1;\n\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n\nvar Recognizer = function () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null;\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options);\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    }\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event);\n\n    if (input.additionalEvent) {\n      emit(input.additionalEvent);\n    }\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n\n    this.state = STATE_FAILED;\n  };\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n\n  _proto.recognize = function recognize(inputData) {\n    var inputDataClone = assign$1({}, inputData);\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    }\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n\n  _proto.process = function process(inputData) {};\n\n  _proto.getTouchAction = function getTouchAction() {};\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n\nvar TapRecognizer = function (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10\n    }, options)) || this;\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    }\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n\nvar AttrRecognizer = function (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input);\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n\nvar PanRecognizer = function (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY;\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n\nvar SwipeRecognizer = function (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\nvar PinchRecognizer = function (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n\nvar RotateRecognizer = function (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n\nvar PressRecognizer = function (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input;\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\nvar defaults = {\n  domEvents: false,\n  touchAction: TOUCH_ACTION_COMPUTE,\n  enable: true,\n  inputTarget: null,\n  inputClass: null,\n  cssProps: {\n    userSelect: \"none\",\n    touchSelect: \"none\",\n    touchCallout: \"none\",\n    contentZooming: \"none\",\n    userDrag: \"none\",\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n\nvar Manager = function () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options);\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    }\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers;\n    var curRecognizer = session.curRecognizer;\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer === curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    }\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer);\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n\n  _proto.emit = function emit(event, data) {\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    }\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\nvar SingleTouchInput = function (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type);\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\nvar Hammer = function () {\n  var Hammer = function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}();\n\nvar defaults$1 = Hammer.defaults;\nexport default Hammer;\nexport { INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, Manager, Input, TouchAction, TouchInput, MouseInput, PointerEventInput, TouchMouseInput, SingleTouchInput, Recognizer, AttrRecognizer, TapRecognizer as Tap, PanRecognizer as Pan, SwipeRecognizer as Swipe, PinchRecognizer as Pinch, RotateRecognizer as Rotate, PressRecognizer as Press, addEventListeners as on, removeEventListeners as off, each, merge, extend, assign$1 as assign, inherit, bindFn, prefixed, toArray, inArray, uniqueArray, splitStr, boolOrFn, hasParent, addEventListeners, removeEventListeners, defaults$1 as defaults };","map":{"version":3,"mappings":"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","names":["assign","Object","target","undefined","TypeError","output","index","arguments","length","source","nextKey","hasOwnProperty","VENDOR_PREFIXES","TEST_ELEMENT","document","style","createElement","TYPE_FUNCTION","round","Math","abs","now","Date","prefixed","obj","property","prefix","prop","camelProp","toUpperCase","slice","i","win","window","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","getTouchActionProps","touchMap","cssSupports","CSS","supports","forEach","val","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","MOBILE_REGEX","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","each","iterator","context","call","boolOrFn","args","apply","inStr","str","find","indexOf","cleanTouchActions","actions","hasPanX","hasPanY","TouchAction","manager","value","set","compute","element","toLowerCase","trim","update","options","touchAction","recognizers","recognizer","enable","concat","getTouchAction","join","preventDefaults","input","srcEvent","direction","offsetDirection","session","prevented","preventDefault","hasNone","isTapPointer","pointers","isTapMovement","distance","isTapTouchTime","deltaTime","preventSrc","hasParent","node","parent","parentNode","getCenter","pointersLength","x","clientX","y","clientY","simpleCloneInputData","timeStamp","center","deltaX","deltaY","getDistance","p1","p2","props","sqrt","getAngle","atan2","PI","getDirection","computeDeltaXY","offset","offsetDelta","prevDelta","prevInput","eventType","getVelocity","getScale","start","end","getRotation","computeIntervalInputData","last","lastInterval","velocity","velocityX","velocityY","v","computeInputData","firstInput","firstMultiple","offsetCenter","angle","overallVelocity","overallVelocityX","overallVelocityY","scale","rotation","maxPointers","srcEventTarget","composedPath","path","inputHandler","pointersLen","changedPointersLen","changedPointers","isFirst","isFinal","emit","recognize","splitStr","split","addEventListeners","types","handler","type","addEventListener","removeEventListeners","removeEventListener","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","Input","callback","self","inputTarget","domHandler","ev","init","evEl","evTarget","evWin","destroy","inArray","src","findByKey","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","PointerEvent","PointerEventInput","proto","prototype","store","_this","pointerEvents","removePointer","eventTypeNormalized","replace","pointerType","isTouch","storeIndex","pointerId","button","push","splice","toArray","Array","uniqueArray","key","sort","results","values","a","b","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","TouchInput","targetIds","touches","getTouches","allTouches","identifier","targetTouches","changedTouches","changedTargetTouches","filter","touch","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","MouseInput","pressed","which","DEDUP_TIMEOUT","DEDUP_DISTANCE","setLastTouch","eventData","primaryTouch","lastTouch","lts","lastTouches","removeLastTouch","setTimeout","recordTouches","isSyntheticEvent","t","dx","dy","TouchMouseInput","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","mouse","createInputInstance","Type","inputClass","invokeArrayArg","arg","fn","isArray","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","_uniqueId","uniqueId","getRecognizerByNameIfManager","otherRecognizer","get","stateStr","state","Recognizer","_extends","id","simultaneous","requireFail","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","event","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","TapRecognizer","taps","interval","time","threshold","posThreshold","pTime","pCenter","_timer","_input","count","validPointers","validMovement","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","_this2","_this3","clearTimeout","AttrRecognizer","_Recognizer","attrTest","optionPointers","isRecognized","isValid","directionStr","PanRecognizer","pX","pY","directionTest","hasMoved","SwipeRecognizer","_AttrRecognizer","PinchRecognizer","inOut","RotateRecognizer","PressRecognizer","validTime","domEvents","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","preset","STOP","FORCED_STOP","toggleCssProps","add","name","oldCssProps","triggerDomEvent","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","Manager","defaults","handlers","item","stop","force","stopped","curRecognizer","existing","remove","targetRecognizer","on","events","off","SINGLE_TOUCH_INPUT_MAP","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","started","normalizeSingleTouches","all","changed","deprecate","method","message","deprecationMessage","e","Error","stack","log","console","warn","extend","dest","merge","keys","inherit","child","base","properties","baseP","childP","create","constructor","_super","bindFn","boundFn","Hammer","VERSION","Tap","Pan","Swipe","Pinch","Rotate","Press"],"sources":["../src/utils/assign.js","../src/utils/utils-consts.js","../src/utils/prefixed.js","../src/browser.js","../src/touchactionjs/get-touchaction-props.js","../src/touchactionjs/touchaction-Consts.js","../src/inputjs/input-consts.js","../src/utils/each.js","../src/utils/bool-or-fn.js","../src/utils/in-str.js","../src/touchactionjs/clean-touch-actions.js","../src/touchactionjs/touchaction-constructor.js","../src/utils/has-parent.js","../src/inputjs/get-center.js","../src/inputjs/simple-clone-input-data.js","../src/inputjs/get-distance.js","../src/inputjs/get-angle.js","../src/inputjs/get-direction.js","../src/inputjs/compute-delta-xy.js","../src/inputjs/get-velocity.js","../src/inputjs/get-scale.js","../src/inputjs/get-rotation.js","../src/inputjs/compute-interval-input-data.js","../src/inputjs/compute-input-data.js","../src/inputjs/input-handler.js","../src/utils/split-str.js","../src/utils/add-event-listeners.js","../src/utils/remove-event-listeners.js","../src/utils/get-window-for-element.js","../src/inputjs/input-constructor.js","../src/utils/in-array.js","../src/input/pointerevent.js","../src/utils/to-array.js","../src/utils/unique-array.js","../src/input/touch.js","../src/input/mouse.js","../src/input/touchmouse.js","../src/inputjs/create-input-instance.js","../src/utils/invoke-array-arg.js","../src/recognizerjs/recognizer-consts.js","../src/utils/unique-id.js","../src/recognizerjs/get-recognizer-by-name-if-manager.js","../src/recognizerjs/state-str.js","../src/recognizerjs/recognizer-constructor.js","../src/recognizers/tap.js","../src/recognizers/attribute.js","../src/recognizerjs/direction-str.js","../src/recognizers/pan.js","../src/recognizers/swipe.js","../src/recognizers/pinch.js","../src/recognizers/rotate.js","../src/recognizers/press.js","../src/defaults.js","../src/manager.js","../src/input/singletouch.js","../src/utils/deprecate.js","../src/utils/extend.js","../src/utils/merge.js","../src/utils/inherit.js","../src/utils/bind-fn.js","../src/hammer.js","../src/index.js"],"sourcesContent":["/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nlet assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let output = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nexport default assign;","\nconst VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nconst TEST_ELEMENT = typeof document === \"undefined\" ? {style: {}} : document.createElement('div');\n\nconst TYPE_FUNCTION = 'function';\n\nconst { round, abs } = Math;\nconst { now } = Date;\n\nexport {\n    VENDOR_PREFIXES,\n    TEST_ELEMENT,\n    TYPE_FUNCTION,\n    round,\n    abs,\n    now\n};\n","import { VENDOR_PREFIXES } from './utils-consts';\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nexport default function prefixed(obj, property) {\n  let prefix;\n  let prop;\n  let camelProp = property[0].toUpperCase() + property.slice(1);\n\n  let i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = (prefix) ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n","/* eslint-disable no-new-func, no-nested-ternary */\n\nlet win;\n\nif (typeof window === \"undefined\") {\n\t// window is undefined in node.js\n\twin = {};\n} else {\n\twin = window;\n}\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexport {win as window};\n","import prefixed from '../utils/prefixed';\nimport { TEST_ELEMENT } from '../utils/utils-consts';\nimport {window} from '../browser';\n\nexport const PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nexport const NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\nexport default function getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  let touchMap = {};\n  let cssSupports = window.CSS && window.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach((val) => {\n\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n","import getTouchActionProps from './get-touchaction-props';\n\n\n\n// magical touchAction value\nconst TOUCH_ACTION_COMPUTE = 'compute';\nconst TOUCH_ACTION_AUTO = 'auto';\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nconst TOUCH_ACTION_NONE = 'none';\nconst TOUCH_ACTION_PAN_X = 'pan-x';\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\nconst TOUCH_ACTION_MAP = getTouchActionProps();\n\nexport {\n  TOUCH_ACTION_AUTO,\n  TOUCH_ACTION_COMPUTE,\n  TOUCH_ACTION_MANIPULATION,\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n  TOUCH_ACTION_MAP\n};\n","import prefixed from '../utils/prefixed';\nimport {window} from \"../browser\";\n\nconst MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nconst SUPPORT_TOUCH = ('ontouchstart' in window);\nconst SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nconst SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nconst INPUT_TYPE_TOUCH = 'touch';\nconst INPUT_TYPE_PEN = 'pen';\nconst INPUT_TYPE_MOUSE = 'mouse';\nconst INPUT_TYPE_KINECT = 'kinect';\n\nconst COMPUTE_INTERVAL = 25;\n\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst INPUT_CANCEL = 8;\n\nconst DIRECTION_NONE = 1;\nconst DIRECTION_LEFT = 2;\nconst DIRECTION_RIGHT = 4;\nconst DIRECTION_UP = 8;\nconst DIRECTION_DOWN = 16;\n\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nconst PROPS_XY = ['x', 'y'];\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\nexport {\n    MOBILE_REGEX,\n    SUPPORT_ONLY_TOUCH,\n    SUPPORT_POINTER_EVENTS,\n    SUPPORT_TOUCH,\n    INPUT_TYPE_KINECT,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_TOUCH,\n    COMPUTE_INTERVAL,\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    DIRECTION_NONE,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_ALL,\n    PROPS_XY,\n    PROPS_CLIENT_XY\n};\n","/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nexport default function each(obj, iterator, context) {\n  let i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n","import { TYPE_FUNCTION } from './utils-consts';\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nexport default function boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n","/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nexport default function inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n","import inStr from '../utils/in-str';\nimport {\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y,\n    TOUCH_ACTION_MANIPULATION,\n    TOUCH_ACTION_AUTO\n} from './touchaction-Consts';\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nexport default function cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n","import {\n    TOUCH_ACTION_COMPUTE,\n    TOUCH_ACTION_MAP,\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y\n} from './touchaction-Consts';\nimport {\n  NATIVE_TOUCH_ACTION,\n  PREFIXED_TOUCH_ACTION,\n} from \"./get-touchaction-props\";\nimport {\n    DIRECTION_VERTICAL,\n    DIRECTION_HORIZONTAL\n} from '../inputjs/input-consts';\nimport each from '../utils/each';\nimport boolOrFn from '../utils/bool-or-fn';\nimport inStr from '../utils/in-str';\nimport cleanTouchActions from './clean-touch-actions';\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nexport default class TouchAction {\n  constructor(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n  set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  }\n\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n  compute() {\n    let actions = [];\n    each(this.manager.recognizers, (recognizer) => {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  }\n\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n  preventDefaults(input) {\n    let { srcEvent } = input;\n    let direction = input.offsetDirection;\n\n    // if the touch action did prevented once this session\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    let { actions } = this;\n    let hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      let isTapPointer = input.pointers.length === 1;\n      let isTapMovement = input.distance < 2;\n      let isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone ||\n        (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n        (hasPanX && direction & DIRECTION_VERTICAL)) {\n      return this.preventSrc(srcEvent);\n    }\n  }\n\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n  preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  }\n}\n","/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nexport default function hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n","import { round } from '../utils/utils-consts';\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nexport default function getCenter(pointers) {\n  let pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n","import { now,round } from '../utils/utils-consts';\nimport getCenter from './get-center';\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nexport default function simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  let pointers = [];\n  let i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nexport default function getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n\n  return Math.sqrt((x * x) + (y * y));\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nexport default function getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n","import { abs } from '../utils/utils-consts';\nimport { DIRECTION_NONE,DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN } from './input-consts';\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nexport default function getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n","import { INPUT_START, INPUT_END } from './input-consts';\n\nexport default function computeDeltaXY(session, input) {\n  let { center } = input;\n  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n  let offset = session.offsetDelta || {};\n  let prevDelta = session.prevDelta || {};\n  let prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n","/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nexport default function getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n","import { PROPS_CLIENT_XY } from './input-consts';\nimport getDistance from './get-distance';\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nexport default function getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n","import getAngle from './get-angle';\nimport { PROPS_CLIENT_XY } from './input-consts';\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nexport default function getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n","import { INPUT_CANCEL,COMPUTE_INTERVAL } from './input-consts';\nimport { abs } from '../utils/utils-consts';\nimport getVelocity from './get-velocity';\nimport getDirection from './get-direction';\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nexport default function computeIntervalInputData(session, input) {\n  let last = session.lastInterval || input;\n  let deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    let deltaX = input.deltaX - last.deltaX;\n    let deltaY = input.deltaY - last.deltaY;\n\n    let v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n","import { now } from '../utils/utils-consts';\nimport { abs } from '../utils/utils-consts';\nimport hasParent from '../utils/has-parent';\nimport simpleCloneInputData from './simple-clone-input-data';\nimport getCenter from './get-center';\nimport getDistance from './get-distance';\nimport getAngle from './get-angle';\nimport getDirection from './get-direction';\nimport computeDeltaXY from './compute-delta-xy';\nimport getVelocity from './get-velocity';\nimport getScale from './get-scale';\nimport getRotation from './get-rotation';\nimport computeIntervalInputData from './compute-interval-input-data';\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nexport default function computeInputData(manager, input) {\n  let { session } = manager;\n  let { pointers } = input;\n  let { length:pointersLength } = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  let { firstInput, firstMultiple } = session;\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  let center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  let overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n  session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n  computeIntervalInputData(session, input);\n\n  // find the correct target\n  let target = manager.element;\n  const srcEvent = input.srcEvent;\n  let srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\n","import { INPUT_START,INPUT_END,INPUT_CANCEL } from './input-consts';\nimport computeInputData from './compute-input-data';\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nexport default function inputHandler(manager, eventType, input) {\n  let pointersLen = input.pointers.length;\n  let changedPointersLen = input.changedPointers.length;\n  let isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n  let isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', input);\n\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n","/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\nexport default function splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function addEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.addEventListener(type, handler, false);\n  });\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function removeEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.removeEventListener(type, handler, false);\n  });\n}\n","/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nexport default function getWindowForElement(element) {\n  let doc = element.ownerDocument || element;\n  return (doc.defaultView || doc.parentWindow || window);\n}\n","import boolOrFn from '../utils/bool-or-fn';\nimport addEventListeners from '../utils/add-event-listeners';\nimport removeEventListeners from '../utils/remove-event-listeners';\nimport getWindowForElement from '../utils/get-window-for-element';\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nexport default class Input {\n  constructor(manager, callback) {\n    let self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n  handler() { }\n\n  /**\n   * @private\n   * bind the events\n   */\n  init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n\n  /**\n   * @private\n   * unbind the events\n   */\n  destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n}\n","/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nexport default function inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    let i = 0;\n    while (i < src.length) {\n      if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {// do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\n","import {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_MOVE,\n    INPUT_TYPE_TOUCH,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_KINECT\n} from '../inputjs/input-consts';\nimport {window} from \"../browser\";\nimport Input from '../inputjs/input-constructor';\nimport inArray from '../utils/in-array';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nconst IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\nexport default class PointerEventInput extends Input {\n  constructor() {\n    var proto = PointerEventInput.prototype;\n\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    super(...arguments);\n    this.store = (this.manager.session.pointerEvents = []);\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let { store } = this;\n    let removePointer = false;\n\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n    let isTouch = (pointerType === INPUT_TYPE_TOUCH);\n\n    // get index of the event in the store\n    let storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n    // start and mouse must be down\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n","/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nexport default function toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n","import inArray from './in-array';\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nexport default function uniqueArray(src, key, sort) {\n  let results = [];\n  let values = [];\n  let i = 0;\n\n  while (i < src.length) {\n    let val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort((a, b) => {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n","import {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport hasParent from '../utils/has-parent';\nimport uniqueArray from '../utils/unique-array';\n\nconst TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nexport default class TouchInput extends Input {\n  constructor() {\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    super(...arguments);\n    this.targetIds = {};\n    // this.evTarget = TOUCH_TARGET_EVENTS;\n  }\n  handler(ev) {\n    let type = TOUCH_INPUT_MAP[ev.type];\n    let touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n  let allTouches = toArray(ev.touches);\n  let { targetIds } = this;\n\n  // when there is only one touch, the process can be simplified\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  let i;\n  let targetTouches;\n  let changedTouches = toArray(ev.changedTouches);\n  let changedTargetTouches = [];\n  let { target } = this;\n\n  // get target touches from touches\n  targetTouches = allTouches.filter((touch) => {\n    return hasParent(touch.target, target);\n  });\n\n  // collect touches\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n\n  // filter changed touches to only contain touches that exist in the collected target ids\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n\n    // cleanup removed touches\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n    changedTargetTouches\n  ];\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_TYPE_MOUSE\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\n\nconst MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\nconst MOUSE_ELEMENT_EVENTS = 'mousedown';\nconst MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\nexport default class MouseInput extends Input {\n  constructor() {\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n\n    super(...arguments);\n    this.pressed = false; // mousedown state\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let eventType = MOUSE_INPUT_MAP[ev.type];\n\n    // on start we want to have the left mouse button down\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    }\n\n    // mouse must be down\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  }\n}\n","import Input from \"../inputjs/input-constructor\";\nimport TouchInput from \"./touch\";\nimport MouseInput from \"./mouse\";\nimport {\n\tINPUT_START,\n\tINPUT_END,\n\tINPUT_CANCEL,\n\tINPUT_TYPE_TOUCH,\n\tINPUT_TYPE_MOUSE,\n} from \"../inputjs/input-consts\";\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nconst DEDUP_TIMEOUT = 2500;\nconst DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n\tconst { changedPointers: [touch] } = eventData;\n\n\tif (touch.identifier === this.primaryTouch) {\n\t\tconst lastTouch = { x: touch.clientX, y: touch.clientY };\n\t\tconst lts = this.lastTouches;\n\n\t\tthis.lastTouches.push(lastTouch);\n\n\n\t\tconst removeLastTouch = function() {\n\t\t\tconst i = lts.indexOf(lastTouch);\n\n\t\t\tif (i > -1) {\n\t\t\t\tlts.splice(i, 1);\n\t\t\t}\n\t\t};\n\n\t\tsetTimeout(removeLastTouch, DEDUP_TIMEOUT);\n\t}\n}\n\n\nfunction recordTouches(eventType, eventData) {\n\tif (eventType & INPUT_START) {\n\t\tthis.primaryTouch = eventData.changedPointers[0].identifier;\n\t\tsetLastTouch.call(this, eventData);\n\t} else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t\tsetLastTouch.call(this, eventData);\n\t}\n}\nfunction isSyntheticEvent(eventData) {\n\tconst x = eventData.srcEvent.clientX;\n\tconst y = eventData.srcEvent.clientY;\n\n\tfor (let i = 0; i < this.lastTouches.length; i++) {\n\t\tconst t = this.lastTouches[i];\n\t\tconst dx = Math.abs(x - t.x);\n\t\tconst dy = Math.abs(y - t.y);\n\n\t\tif (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nexport default class TouchMouseInput extends Input {\n\tconstructor(manager, callback) {\n\t\tsuper(manager, callback);\n\n\t\tthis.touch = new TouchInput(this.manager, this.handler);\n\t\tthis.mouse = new MouseInput(this.manager, this.handler);\n\t\tthis.primaryTouch = null;\n\t\tthis.lastTouches = [];\n\t}\n\n\t/**\n\t * @private\n\t * handle mouse and touch events\n\t * @param {Hammer} manager\n\t * @param {String} inputEvent\n\t * @param {Object} inputData\n\t */\n\thandler = (manager, inputEvent, inputData) => {\n\t\tconst isTouch = (inputData.pointerType === INPUT_TYPE_TOUCH);\n\t\tconst isMouse = (inputData.pointerType === INPUT_TYPE_MOUSE);\n\n\t\tif (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n\t\t\treturn;\n\t\t}\n\n\t\t// when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\t\tif (isTouch) {\n\t\t\trecordTouches.call(this, inputEvent, inputData);\n\t\t} else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.callback(manager, inputEvent, inputData);\n\t}\n\n\t/**\n\t * @private\n\t * remove the event listeners\n\t */\n\tdestroy() {\n\t\tthis.touch.destroy();\n\t\tthis.mouse.destroy();\n\t}\n}\n","import { SUPPORT_POINTER_EVENTS,SUPPORT_ONLY_TOUCH,SUPPORT_TOUCH } from './input-consts';\nimport inputHandler from './input-handler';\nimport PointerEventInput from '../input/pointerevent';\nimport TouchInput from '../input/touch';\nimport MouseInput from '../input/mouse';\nimport TouchMouseInput from '../input/touchmouse';\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nexport default function createInputInstance(manager) {\n  let Type;\n  // let inputClass = manager.options.inputClass;\n  let { options:{ inputClass } } = manager;\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new (Type)(manager, inputHandler);\n}\n","import each from './each';\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nexport default function invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\n","const STATE_POSSIBLE = 1;\nconst STATE_BEGAN = 2;\nconst STATE_CHANGED = 4;\nconst STATE_ENDED = 8;\nconst STATE_RECOGNIZED = STATE_ENDED;\nconst STATE_CANCELLED = 16;\nconst STATE_FAILED = 32;\n\nexport {\n    STATE_POSSIBLE,\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_ENDED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_FAILED\n};\n","/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nlet _uniqueId = 1;\nexport default function uniqueId() {\n  return _uniqueId++;\n}\n","/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nexport default function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  let { manager } = recognizer;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n","import {\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_CHANGED,\n    STATE_BEGAN\n} from './recognizer-consts';\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\nexport default function stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n","import {\n    STATE_POSSIBLE,\n    STATE_ENDED,\n    STATE_FAILED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_BEGAN,\n    STATE_CHANGED\n} from './recognizer-consts';\nimport assign from '../utils/assign';\nimport uniqueId from '../utils/unique-id';\nimport invokeArrayArg from '../utils/invoke-array-arg';\nimport inArray from '../utils/in-array';\nimport boolOrFn from '../utils/bool-or-fn';\nimport getRecognizerByNameIfManager from './get-recognizer-by-name-if-manager';\nimport stateStr from './state-str';\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nexport default class Recognizer {\n  constructor(options = {}) {\n    this.options = {\n      enable: true,\n      ...options,\n    };\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n  set(options) {\n    assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager && this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    let { simultaneous } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  }\n\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    let { requireFail } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    let index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n  hasRequireFailures() {\n    return this.requireFail.length > 0;\n  }\n\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n  canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  }\n\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n  emit(input) {\n    let self = this;\n    let { state } = this;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    }\n\n    // 'panstart' and 'panmove'\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    }\n\n    // panend and pancancel\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  }\n\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n  tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n    // it's failing anyway\n    this.state = STATE_FAILED;\n  }\n\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n  canEmit() {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    let inputDataClone = assign({}, inputData);\n\n    // is is enabled and allow recognizing?\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n  process(inputData) { }\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n  getTouchAction() { }\n\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n  reset() { }\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport { TOUCH_ACTION_MANIPULATION } from '../touchactionjs/touchaction-Consts';\nimport {INPUT_START,INPUT_END } from '../inputjs/input-consts';\nimport {\n    STATE_RECOGNIZED,\n    STATE_BEGAN,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport getDistance from '../inputjs/get-distance';\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nexport default class TapRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300, // max time between the multi-tap taps\n      time: 250, // max time of the pointer to be down (like finger on the screen)\n      threshold: 9, // a minimal movement is ok, but keep it low\n      posThreshold: 10, // a multi-tap can be a bit off the initial position\n      ...options,\n    });\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input) {\n    let { options } = this;\n\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if ((input.eventType & INPUT_START) && (this.count === 0)) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      let validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n      let validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      let tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(() => {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  }\n\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport {\n    INPUT_CANCEL,\n    INPUT_END\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nexport default class AttrRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      pointers: 1,\n      ...options,\n    });\n  }\n\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n  attrTest(input) {\n    let optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n  process(input) {\n    let { state } = this;\n    let { eventType } = input;\n\n    let isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    let isValid = this.attrTest(input);\n\n    // on cancel input and we've recognized before, return STATE_CANCELLED\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  }\n}\n","import {\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\nexport default function directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n","import  AttrRecognizer from './attribute';\nimport {\n    DIRECTION_ALL,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_NONE,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT\n} from '../inputjs/input-consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\nimport { TOUCH_ACTION_PAN_X,TOUCH_ACTION_PAN_Y } from '../touchactionjs/touchaction-Consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PanRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL,\n      ...options,\n    });\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction() {\n    let { options:{ direction } } = this;\n    let actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  directionTest(input) {\n    let { options } = this;\n    let hasMoved = true;\n    let { distance } = input;\n    let { direction } = input;\n    let x = input.deltaX;\n    let y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  }\n\n  attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call\n        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n  }\n\n  emit(input) {\n\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    let direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n","import AttrRecognizer from '../recognizers/attribute';\nimport { abs } from '../utils/utils-consts';\nimport { DIRECTION_HORIZONTAL,DIRECTION_VERTICAL } from '../inputjs/input-consts';\nimport PanRecognizer from './pan';\nimport { INPUT_END } from '../inputjs/input-consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class SwipeRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  attrTest(input) {\n    let { direction } = this.options;\n    let velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return super.attrTest(input) &&\n        direction & input.offsetDirection &&\n        input.distance > this.options.threshold &&\n        input.maxPointers === this.options.pointers &&\n        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  }\n\n  emit(input) {\n    let direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PinchRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n\n  emit(input) {\n    if (input.scale !== 1) {\n      let inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    super.emit(input);\n  }\n}\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class RotateRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super( {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_RECOGNIZED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport { now } from '../utils/utils-consts';\nimport { TOUCH_ACTION_AUTO } from '../touchactionjs/touchaction-Consts';\nimport {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nexport default class PressRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      event: 'press',\n      pointers: 1,\n      time: 251, // minimal time of the pointer to be pressed\n      threshold: 9, // a minimal movement is ok, but keep it low\n      ...options,\n    });\n    this._timer = null;\n    this._input = null;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  process(input) {\n    let { options } = this;\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(() => {\n        this.state = STATE_RECOGNIZED;\n        this.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && (input.eventType & INPUT_END)) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n\n","import { TOUCH_ACTION_COMPUTE } from \"./touchactionjs/touchaction-Consts\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\nimport {DIRECTION_HORIZONTAL} from \"./inputjs/input-consts\";\n\nexport default {\n\t/**\n\t * @private\n\t * set if DOM events are being triggered.\n\t * But this is slower and unused by simple implementations, so disabled by default.\n\t * @type {Boolean}\n\t * @default false\n\t */\n\tdomEvents: false,\n\n\t/**\n\t * @private\n\t * The value for the touchAction property/fallback.\n\t * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t * @type {String}\n\t * @default compute\n\t */\n\ttouchAction: TOUCH_ACTION_COMPUTE,\n\n\t/**\n\t * @private\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tenable: true,\n\n\t/**\n\t * @private\n\t * EXPERIMENTAL FEATURE -- can be removed/changed\n\t * Change the parent input target element.\n\t * If Null, then it is being set the to main element.\n\t * @type {Null|EventTarget}\n\t * @default null\n\t */\n\tinputTarget: null,\n\n\t/**\n\t * @private\n\t * force an input class\n\t * @type {Null|Function}\n\t * @default null\n\t */\n\tinputClass: null,\n\n\t/**\n\t * @private\n\t * Some CSS properties can be used to improve the working of Hammer.\n\t * Add them to this method and they will be set when creating a new Manager.\n\t * @namespace\n\t */\n\tcssProps: {\n\t\t/**\n\t\t * @private\n\t\t * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tuserSelect: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Disable the Windows Phone grippers when pressing an element.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\ttouchSelect: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Disables the default callout shown when you touch and hold a touch target.\n\t\t * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t\t * a callout containing information about the link. This property allows you to disable that callout.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\ttouchCallout: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Specifies whether zooming is enabled. Used by IE10>\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tcontentZooming: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tuserDrag: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t\t * clickable element in iOS. This property obeys the alpha value, if specified.\n\t\t * @type {String}\n\t\t * @default 'rgba(0,0,0,0)'\n\t\t */\n\t\ttapHighlightColor: \"rgba(0,0,0,0)\",\n\t},\n};\n\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\nexport const preset = [\n  [RotateRecognizer, { enable: false }],\n  [PinchRecognizer, { enable: false }, ['rotate']],\n  [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n  [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n  [TapRecognizer],\n  [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n  [PressRecognizer]\n];\n","import assign from \"./utils/assign\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport createInputInstance from \"./inputjs/create-input-instance\";\nimport each from \"./utils/each\";\nimport inArray from \"./utils/in-array\";\nimport invokeArrayArg from \"./utils/invoke-array-arg\";\nimport splitStr from \"./utils/split-str\";\nimport prefixed from \"./utils/prefixed\";\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport {\n  STATE_BEGAN,\n  STATE_ENDED,\n  STATE_CHANGED,\n  STATE_RECOGNIZED,\n} from \"./recognizerjs/recognizer-consts\";\nimport defaults from \"./defaults\";\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\n\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n  const { element } = manager;\n\n  if (!element.style) {\n    return;\n  }\n  let prop;\n\n  each(manager.options.cssProps, (value, name) => {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n  const gestureEvent = document.createEvent(\"Event\");\n\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n\n\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Manager {\n  constructor(element, options) {\n    this.options = assign({}, defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, item => {\n      const recognizer = this.add(new (item[0])(item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n\t/**\n\t * @private\n\t * set options\n\t * @param {Object} options\n\t * @returns {Manager}\n\t */\n  set(options) {\n    assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n\n\t/**\n\t * @private\n\t * stop recognizing for this session.\n\t * This session will be discarded, when a new [input]start event is fired.\n\t * When forced, the recognizer cycle is stopped immediately.\n\t * @param {Boolean} [force]\n\t */\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n\t/**\n\t * @private\n\t * run the recognizers!\n\t * called by the inputHandler function on every movement of the pointers (touches)\n\t * it walks through all the recognizers and tries to detect the gesture that is being made\n\t * @param {Object} inputData\n\t */\n  recognize(inputData) {\n    const { session } = this;\n\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    this.touchAction.preventDefaults(inputData);\n\n    let recognizer;\n    const { recognizers } = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let { curRecognizer } = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    let i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (session.stopped !== FORCED_STOP && (// 1\n        !curRecognizer || recognizer === curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) { // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n\t/**\n\t * @private\n\t * get a recognizer by its event name.\n\t * @param {Recognizer|String} recognizer\n\t * @returns {Recognizer|Null}\n\t */\n  get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    const { recognizers } = this;\n\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n\t/**\n\t * @private add a recognizer to the manager\n\t * existing recognizers with the same event name will be removed\n\t * @param {Recognizer} recognizer\n\t * @returns {Recognizer|Manager}\n\t */\n  add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    }\n\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n\t/**\n\t * @private\n\t * remove a recognizer by name or instance\n\t * @param {Recognizer|String} recognizer\n\t * @returns {Manager}\n\t */\n  remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    const targetRecognizer = this.get(recognizer);\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const { recognizers } = this;\n      const index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n\t/**\n\t * @private\n\t * bind event\n\t * @param {String} events\n\t * @param {Function} handler\n\t * @returns {EventEmitter} this\n\t */\n  on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    const { handlers } = this;\n\n    each(splitStr(events), event => {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  }\n\n\t/**\n\t * @private unbind event, leave emit blank to remove all handlers\n\t * @param {String} events\n\t * @param {Function} [handler]\n\t * @returns {EventEmitter} this\n\t */\n  off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    const { handlers } = this;\n\n    each(splitStr(events), event => {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  }\n\n\t/**\n\t * @private emit event to the listeners\n\t * @param {String} event\n\t * @param {Object} data\n\t */\n  emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    }\n\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    let i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  }\n\n\t/**\n\t * @private\n\t * destroy the manager and unbinds all events\n\t * it doesn't unbind dom events, that is the user own responsibility\n\t */\n  destroy() {\n    this.element && toggleCssProps(this, false);\n\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport uniqueArray from '../utils/unique-array';\n\nconst SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nconst SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\nexport default class SingleTouchInput extends Input {\n  constructor() {\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\n    super(...arguments);\n    this.started = false;\n  }\n\n  handler(ev) {\n    let type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n    // should we handle the touch events?\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    let touches = normalizeSingleTouches.call(this, ev, type);\n\n    // when done, reset the started state\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n  let all = toArray(ev.touches);\n  let changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n","/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nexport default function deprecate(method, name, message) {\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\n  return function() {\n    let e = new Error('get-stack-trace');\n    let stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n        .replace(/^\\s+at\\s+/gm, '')\n        .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n    let log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n","import deprecate from './deprecate';\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nconst extend = deprecate((dest, src, merge) => {\n  let keys = Object.keys(src);\n  let i = 0;\n  while (i < keys.length) {\n    if (!merge || (merge && dest[keys[i]] === undefined)) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\nexport default extend;\n","import deprecate from './deprecate';\nimport extend from './extend';\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nconst merge = deprecate((dest, src) => {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\nexport default merge;\n","import assign from './assign';\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nexport default function inherit(child, base, properties) {\n  let baseP = base.prototype;\n  let childP;\n\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign(childP, properties);\n  }\n}\n","/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nexport default function bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n","import Manager from \"./manager\";\nimport defaults, { preset } from \"./defaults\";\nimport assign from './utils/assign';\nimport {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./inputjs/input-consts\";\nimport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n} from \"./recognizerjs/recognizer-consts\";\n\nimport Input from \"./inputjs/input-constructor\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport TouchInput from \"./input/touch\";\nimport MouseInput from \"./input/mouse\";\nimport PointerEventInput from \"./input/pointerevent\";\nimport SingleTouchInput from \"./input/singletouch\";\nimport TouchMouseInput from \"./input/touchmouse\";\n\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport AttrRecognizer from \"./recognizers/attribute\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\n\nimport addEventListeners from \"./utils/add-event-listeners\";\nimport removeEventListeners from \"./utils/remove-event-listeners\";\nimport each from \"./utils/each\";\nimport merge from \"./utils/merge\";\nimport extend from \"./utils/extend\";\nimport inherit from \"./utils/inherit\";\nimport bindFn from \"./utils/bind-fn\";\nimport prefixed from \"./utils/prefixed\";\nimport toArray from \"./utils/to-array\";\nimport uniqueArray from \"./utils/unique-array\";\nimport splitStr from \"./utils/split-str\";\nimport inArray from \"./utils/in-array\";\nimport boolOrFn from \"./utils/bool-or-fn\";\nimport hasParent from \"./utils/has-parent\";\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Hammer {\n\t/**\n   * @private\n   * @const {string}\n   */\n\tstatic VERSION = \"#__VERSION__#\";\n\tstatic DIRECTION_ALL = DIRECTION_ALL;\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\n\tstatic DIRECTION_LEFT = DIRECTION_LEFT;\n\tstatic DIRECTION_RIGHT = DIRECTION_RIGHT;\n\tstatic DIRECTION_UP = DIRECTION_UP;\n\tstatic DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n\tstatic DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n\tstatic DIRECTION_NONE = DIRECTION_NONE;\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\n\tstatic INPUT_START = INPUT_START;\n\tstatic INPUT_MOVE = INPUT_MOVE;\n  static INPUT_END = INPUT_END;\n\tstatic INPUT_CANCEL = INPUT_CANCEL;\n\tstatic STATE_POSSIBLE = STATE_POSSIBLE;\n\tstatic STATE_BEGAN = STATE_BEGAN;\n\tstatic STATE_CHANGED = STATE_CHANGED;\n\tstatic STATE_ENDED = STATE_ENDED;\n\tstatic STATE_RECOGNIZED = STATE_RECOGNIZED;\n\tstatic STATE_CANCELLED = STATE_CANCELLED;\n\tstatic STATE_FAILED = STATE_FAILED;\n\tstatic Manager = Manager;\n\tstatic Input = Input;\n\tstatic TouchAction = TouchAction;\n\tstatic TouchInput = TouchInput;\n\tstatic MouseInput = MouseInput;\n\tstatic PointerEventInput = PointerEventInput;\n\tstatic TouchMouseInput = TouchMouseInput;\n\tstatic SingleTouchInput = SingleTouchInput;\n\tstatic Recognizer = Recognizer;\n\tstatic AttrRecognizer = AttrRecognizer;\n\tstatic Tap = TapRecognizer;\n\tstatic Pan = PanRecognizer;\n\tstatic Swipe = SwipeRecognizer;\n\tstatic Pinch = PinchRecognizer;\n\tstatic Rotate = RotateRecognizer;\n\tstatic Press = PressRecognizer;\n\tstatic on = addEventListeners;\n\tstatic off = removeEventListeners;\n\tstatic each = each;\n\tstatic merge = merge;\n\tstatic extend = extend;\n\tstatic bindFn = bindFn;\n\tstatic assign = assign;\n\tstatic inherit = inherit;\n\tstatic bindFn = bindFn;\n\tstatic prefixed = prefixed;\n\tstatic toArray = toArray;\n\tstatic inArray = inArray;\n\tstatic uniqueArray = uniqueArray;\n\tstatic splitStr = splitStr;\n\tstatic boolOrFn = boolOrFn;\n\tstatic hasParent = hasParent;\n\tstatic addEventListeners = addEventListeners;\n\tstatic removeEventListeners = removeEventListeners;\n\tstatic defaults = assign({}, defaults, { preset });\n\tconstructor(element, options = {}) {\n\t\treturn new Manager(element, {\n\t\t\trecognizers: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        ...preset\n\t\t\t],\n\t\t\t...options,\n\t\t});\n\t}\n}\n","\nimport Hammer from \"./hammer\";\nimport assign from \"./utils/assign\";\n\nimport {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./inputjs/input-consts\";\nimport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n} from \"./recognizerjs/recognizer-consts\";\n\nimport Manager from \"./manager\";\nimport Input from \"./inputjs/input-constructor\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport TouchInput from \"./input/touch\";\nimport MouseInput from \"./input/mouse\";\nimport PointerEventInput from \"./input/pointerevent\";\nimport SingleTouchInput from \"./input/singletouch\";\nimport TouchMouseInput from \"./input/touchmouse\";\n\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport AttrRecognizer from \"./recognizers/attribute\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\n\nimport addEventListeners from \"./utils/add-event-listeners\";\nimport removeEventListeners from \"./utils/remove-event-listeners\";\nimport each from \"./utils/each\";\nimport merge from \"./utils/merge\";\nimport extend from \"./utils/extend\";\nimport inherit from \"./utils/inherit\";\nimport bindFn from \"./utils/bind-fn\";\nimport prefixed from \"./utils/prefixed\";\nimport toArray from \"./utils/to-array\";\nimport uniqueArray from \"./utils/unique-array\";\nimport splitStr from \"./utils/split-str\";\nimport inArray from \"./utils/in-array\";\nimport boolOrFn from \"./utils/bool-or-fn\";\nimport hasParent from \"./utils/has-parent\";\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\n\nconst defaults = Hammer.defaults;\n\nexport {\n  Hammer as default,\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n  Manager,\n  Input,\n  TouchAction,\n  TouchInput,\n  MouseInput,\n  PointerEventInput,\n  TouchMouseInput,\n  SingleTouchInput,\n  Recognizer,\n  AttrRecognizer,\n  TapRecognizer as Tap,\n  PanRecognizer as Pan,\n  SwipeRecognizer as Swipe,\n  PinchRecognizer as Pinch,\n  RotateRecognizer as Rotate,\n  PressRecognizer as Press,\n  addEventListeners as on,\n  removeEventListeners as off,\n  each,\n  merge,\n  extend,\n  assign,\n  inherit,\n  bindFn,\n  prefixed,\n  toArray,\n  inArray,\n  uniqueArray,\n  splitStr,\n  boolOrFn,\n  hasParent,\n  addEventListeners,\n  removeEventListeners,\n  defaults,\n};\n"]},"metadata":{},"sourceType":"module"}